title: 解决跨域问题
date: 2014-06-06 11:53:20
categories: [JavaScript]
tags: [JavaScript, nodejs]
---
服务器端不存在跨域问题，客户端ajax请求的时候，如果报错:

```
XMLHttpRequest cannot load xxxxx. Origin http://localhost is not allowed by Access-Control-Allow-Origin.
```
恭喜你，这就出现了跨域问题。
<!--more-->

## 问题来源
微信开发模式下，需要验证TOKEN。我使用的后台环境是nodejs。网上没有很直接的教程，所以我自己写了一个验证代码：
```
var http = require('http');
var url = require('url');
var crypto = require('crypto');

function sha1(str) {
    var md5sum = crypto.createHash('sha1');
    md5sum.update(str);
    str = md5sum.digest('hex');
    return str;
}
http.createServer(function(req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});

    var url_parts = url.parse(req.url, true);
    var query = url_parts.query;

    var signature = query.signature;
    var echostr = query.echostr;
    var timestamp = query.timestamp;
    var nonce = query.nonce;

    var oriArray = new Array();
    oriArray[0] = nonce;
    oriArray[1] = timestamp;
    oriArray[2] = "XXXXX"; // your token  
    oriArray.sort();
    var original = oriArray[0] + oriArray[1] + oriArray[2];
    var scyptoString = sha1(original);
    if (signature == scyptoString) {
        console.log('True')
        res.end(echostr);
    } else {
        console.log('False')
        res.end("Bad Token!");
    }
}).listen(5000);
console.log('Server running at http::5000/');
```
注意，这里我绑定的是`5000`端口，但是微信必须是`80`端口，所以我在服务器端使用了`nginx`代理，设置的主要代码如下:
```
upstream nodejs__upstream2 {
     server 127.0.0.1:5000;
     keepalive 64;
}
server {
     listen 80;
     # server_name为你的主机IP
     server_name 128.199.209.206; 
     location / {
         proxy_set_header   X-Real-IP            $remote_addr;
         proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
         proxy_set_header   Host                   $http_host;
         proxy_set_header   X-NginX-Proxy    true;
         proxy_set_header   Connection "";
         proxy_http_version 1.1;
         proxy_pass         http://nodejs__upstream2;
     }
}
```

理所当然的我会首先在本地进行下测试，首先想到了利用Ajax请求。测试代码:
```
<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test Get</title>
</head>

<body>

    <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>

    <script>
    $(function() {

        var data = {
            signature: '7032b0ab6a41f2fb382d782d1dd8a65e12b2dfb2',
            echostr: '5904622633625829580',
            timestamp: '1375715532',
            nonce: '1374777116'
        };

        $.ajax({
            type: "GET",
            url: "http://localhost:5000",
            data: data
        }).done(function(data) {
            console.log('success:',data);
        });
    })
    </script>
</body>

</html>

```

Chrome下打开开发者工具，看到报错信息如下:
```
GET http://localhost:5000/?signature=7032b0ab6a41f2fb382d782d1dd8a65e12b2dfb2&echostr=5904622633625829580&timestamp=1375715532&nonce=1374777116 net::ERR_CONNECTION_REFUSED jquery.js:8617
```

说明一下，我这里返回的是字符串，而不是json数据。所以我没有使用getJSON方法。
## 解决方案
### JSONP
JSONP是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。

```
var http = require('http');
var url = require('url');
var crypto = require('crypto');

function sha1(str) {
    var md5sum = crypto.createHash('sha1');
    md5sum.update(str);
    str = md5sum.digest('hex');
    return str;
}
http.createServer(function(req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});

    var url_parts = url.parse(req.url, true);
    var query = url_parts.query;

    var signature = query.signature;
    var echostr = query.echostr;
    var timestamp = query.timestamp;
    var nonce = query.nonce;
    var jsoncallback = query.callback;

    console.log(query)
    var oriArray = new Array();
    oriArray[0] = nonce;
    oriArray[1] = timestamp;
    oriArray[2] = "XXXXX"; // your token  
    oriArray.sort();
    var original = oriArray[0] + oriArray[1] + oriArray[2];
    var scyptoString = sha1(original);
    if (signature == scyptoString) {
        console.log('True')
        res.end(jsoncallback+"("+ echostr +")");
    } else {
        console.log('False')
        res.end(jsoncallback+"('Bad Token!')");
    }
}).listen(5000);
console.log('Server running at http::5000/');
```

客户端代码修改为:
```
$.ajax({
    type: "GET",
    url: "http://localhost:5000",
    data: data,
    dataType:'JSONP'
}).done(function(data) {
    console.log('success:',data);
});
```

JSONP是用一个callback包裹所要传递的数据，本地指定了`dataType`的话，就能正常访问了。

### 设置服务器端的Header
主要是这一段，`Access-Control-Allow-Origin：*`。

服务器端的程序如下:
```
var http = require('http');
var url = require('url');
var crypto = require('crypto');

function sha1(str) {
    var md5sum = crypto.createHash('sha1');
    md5sum.update(str);
    str = md5sum.digest('hex');
    return str;
}
http.createServer(function(req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain',
                        'Access-Control-Allow-Origin': '*'});

    var url_parts = url.parse(req.url, true);
    var query = url_parts.query;

    var signature = query.signature;
    var echostr = query.echostr;
    var timestamp = query.timestamp;
    var nonce = query.nonce;
    var jsoncallback = query.jsonpcallback;

    var oriArray = new Array();
    oriArray[0] = nonce;
    oriArray[1] = timestamp;
    oriArray[2] = "XXXXX"; // your token  
    oriArray.sort();
    var original = oriArray[0] + oriArray[1] + oriArray[2];
    var scyptoString = sha1(original);
    if (signature == scyptoString) {
        console.log('True')
        // res.end(jsoncallback+"("+ echostr +")");
        res.end(echostr);
    } else {
        console.log('False')
        // res.end(jsoncallback+"('Bad Token!')");
        res.end("Bad Token!");
    }
}).listen(5000);
console.log('Server running at http::5000/');
```

客户端还是那样访问:
```
$.ajax({
    type: "GET",
    url: "http://localhost:5000",
    data: data
}).done(function(data) {
    console.log('success:',data);
});
```

### 服务器端处理
服务器端处理请求的话不存在跨域问题，所以我使用Nodejs充当了客户端的角色:
```
var http = require("http");

var options = {
    "host": "localhost",
    "port": "5000",
    "path": "/"
};

http.get(options, function(res) {
    console.log("Site Status:", res.statusCode);
    console.log(res.headers);
    res.on('data', function (chunk) {
        console.log('Data:' + chunk);
      });

    if (res.statusCode == 200) {
        console.log("The site is up!\n");
    } else {
        console.log("The site is down!\n");
    }
}).on("error", function(e) {
    console.log("There was an error:", e.message);
});
```


## 参考资料
- [JS通过服务器代理解决跨域问题](http://developer.yahoo.com/javascript/howto-proxy.html)
